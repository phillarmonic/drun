# Complete Demo: Lifecycle + Namespacing
# This example demonstrates both lifecycle management and recipe namespacing

version: 1.0

# Project configuration
vars:
  project_name: "complete-demo"
  version: 1.2.0
  environment: "development"

env:
  PROJECT_ROOT: "."
  BUILD_DATE: '{{ now "2006-01-02T15:04:05Z" }}'

# Include namespaced recipes to prevent collisions
include:
  # Docker operations with docker: namespace
  - "docker::shared/docker-common.yml"
  
  # You could also include other namespaced files:
  # - "k8s::shared/kubernetes.yml"
  # - "ci::shared/ci-pipeline.yml"
  # - "test::shared/testing.yml"

# Reusable snippets
snippets:
  setup_colors: |
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    PURPLE='\033[0;35m'
    CYAN='\033[0;36m'
    NC='\033[0m'

  log_functions: |
    log_info() { echo -e "${BLUE}ℹ️  $1${NC}"; }
    log_success() { echo -e "${GREEN}✅ $1${NC}"; }
    log_warning() { echo -e "${YELLOW}⚠️  $1${NC}"; }
    log_error() { echo -e "${RED}❌ $1${NC}"; }
    log_step() { echo -e "${PURPLE}🔄 $1${NC}"; }

  check_tools: |
    check_tool() {
      if ! command -v "$1" >/dev/null 2>&1; then
        log_error "Required tool not found: $1"
        return 1
      fi
    }

# Recipe-Prerun: Before every recipe
recipe-prerun:
  - '{{ snippet "setup_colors" }}'
  - '{{ snippet "log_functions" }}'
  - '{{ snippet "check_tools" }}'
  - |
    set -euo pipefail
    log_info "Recipe-prerun completed for recipe: ${DRUN_RECIPE_NAME:-unknown}"

# Recipe-Postrun: After every recipe
recipe-postrun:
  - |
    # Log recipe completion with timing
    if [ $? -eq 0 ]; then
      log_success "Recipe completed successfully at $(date)"
    else
      log_error "Recipe failed at $(date) with exit code $?"
    fi
  - |
    # Per-recipe metrics and cleanup
    echo "Recipe execution summary:"
    echo "  - Exit code: $?"
    echo "  - Timestamp: $(date -Iseconds)"
    echo "  - Working dir: $(pwd)"

# Before: Once before any recipe execution
before:
  - |
    echo ""
    echo -e "${CYAN}🚀 === {{ .project_name | upper }} BUILD PIPELINE ===${NC}"
    echo -e "${BLUE}Version: {{ .version }}${NC}"
    echo -e "${BLUE}Environment: {{ .environment }}${NC}"
    echo -e "${BLUE}Build Date: {{ .BUILD_DATE }}${NC}"
    echo -e "${BLUE}Working Directory: {{ .PROJECT_ROOT }}${NC}"
    echo ""
    
    export PIPELINE_START_TIME=$(date +%s)
    export PIPELINE_ID="build-$(date +%Y%m%d-%H%M%S)"
    log_info "Pipeline ID: $PIPELINE_ID"

  - |
    log_step "Validating build environment..."
    
    # Check required tools
    REQUIRED_TOOLS="git date mkdir rm"
    for tool in $REQUIRED_TOOLS; do
      check_tool "$tool"
    done
    
    # Create pipeline directories
    mkdir -p .pipeline/{logs,artifacts,reports}
    echo "$PIPELINE_ID" > .pipeline/pipeline-id.txt
    
    log_success "Environment validation passed"

  - |
    log_step "Initializing pipeline state..."
    
    # Create pipeline state file
    cat > .pipeline/state.env << 'EOF'
    pipeline_id=$PIPELINE_ID
    project={{ .project_name }}
    version={{ .version }}
    environment={{ .environment }}
    start_time=$PIPELINE_START_TIME
    build_date={{ .BUILD_DATE }}
    EOF
    
    log_success "Pipeline state initialized"

# After: Once after all recipe execution
after:
  - |
    echo ""
    log_step "Starting pipeline cleanup..."
    
    # Load pipeline state
    if [ -f .pipeline/state.env ]; then
      source .pipeline/state.env
      log_info "Pipeline ID: $pipeline_id"
    fi

  - |
    log_step "Generating pipeline report..."
    
    REPORT_FILE=".pipeline/reports/pipeline-report-$(date +%Y%m%d-%H%M%S).json"
    
    # Calculate duration
    DURATION=""
    if [ -n "${PIPELINE_START_TIME:-}" ]; then
      END_TIME=$(date +%s)
      DURATION=$((END_TIME - PIPELINE_START_TIME))
    fi
    
    # Generate JSON report
    cat > "$REPORT_FILE" << 'EOF'
    {
      "pipeline_id": "${PIPELINE_ID:-unknown}",
      "project": "{{ .project_name }}",
      "version": "{{ .version }}",
      "environment": "{{ .environment }}",
      "start_time": "${PIPELINE_START_TIME:-unknown}",
      "end_time": "$(date +%s)",
      "duration_seconds": ${DURATION:-0},
      "build_date": "{{ .BUILD_DATE }}",
      "status": "completed",
      "generated_at": "$(date -Iseconds)"
    }
    EOF
    
    log_success "Pipeline report generated: $REPORT_FILE"

  - |
    log_step "Archiving artifacts..."
    
    # Archive important files
    if [ -d build ] || [ -d dist ] || [ -d target ]; then
      ARCHIVE_NAME=".pipeline/artifacts/artifacts-$(date +%Y%m%d-%H%M%S).tar.gz"
      tar -czf "$ARCHIVE_NAME" \
        $(find . -maxdepth 1 -type d \( -name "build" -o -name "dist" -o -name "target" \) 2>/dev/null) \
        2>/dev/null || true
      
      if [ -f "$ARCHIVE_NAME" ]; then
        log_success "Artifacts archived: $ARCHIVE_NAME"
      fi
    fi

  - |
    # Final summary
    echo ""
    echo -e "${CYAN}🏁 === PIPELINE COMPLETED ===${NC}"
    
    if [ -n "${PIPELINE_START_TIME:-}" ]; then
      DURATION=$(($(date +%s) - PIPELINE_START_TIME))
      MINUTES=$((DURATION / 60))
      SECONDS=$((DURATION % 60))
      
      if [ $MINUTES -gt 0 ]; then
        log_success "Total pipeline time: ${MINUTES}m ${SECONDS}s"
      else
        log_success "Total pipeline time: ${SECONDS}s"
      fi
    fi
    
    echo -e "${GREEN}✨ All pipeline phases completed successfully!${NC}"
    echo ""

# Local recipes
recipes:
  # Default recipe
  default:
    help: "Show available commands and pipeline overview"
    run: |
      log_info "{{ .project_name }} v{{ .version }} - Complete Demo Pipeline"
      echo ""
      echo "This demo showcases:"
      echo "  🔄 Lifecycle management (before/after blocks)"
      echo "  📦 Recipe namespacing (docker: prefix)"
      echo "  🔗 Cross-namespace dependencies"
      echo ""
      echo "Available commands:"
      echo ""
      echo "Local recipes:"
      echo "  setup       - Initialize project"
      echo "  build       - Build application"
      echo "  test        - Run tests"
      echo "  package     - Create distribution package"
      echo "  deploy      - Deploy to environment"
      echo "  full-ci     - Complete CI pipeline"
      echo ""
      echo "Docker recipes (namespaced):"
      echo "  docker:build - Build Docker image"
      echo "  docker:push  - Push to registry"
      echo "  docker:run   - Run container"
      echo "  docker:clean - Clean up Docker resources"
      echo ""
      echo "Try: drun full-ci"

  # Setup recipe
  setup:
    help: "Initialize project setup"
    run: |
      log_step "Setting up {{ .project_name }}..."
      
      # Create project structure
      mkdir -p {src,tests,docs,config}
      
      # Create sample files
      echo "# {{ .project_name }}" > README.md
      echo "version = '{{ .version }}'" > src/version.txt
      echo "environment = '{{ .environment }}'" > config/app.conf
      
      # Create a simple Dockerfile for Docker demos
      cat > Dockerfile << 'EOF'
      FROM alpine:latest
      RUN apk add --no-cache curl
      WORKDIR /app
      COPY src/ ./src/
      COPY config/ ./config/
      EXPOSE 8080
      CMD ["sh", "-c", "echo 'App running on port 8080' && sleep 3600"]
      EOF
      
      log_success "Project setup completed"

  # Build recipe
  build:
    help: "Build the application"
    deps: ["setup"]
    run: |
      log_step "Building {{ .project_name }} v{{ .version }}..."
      
      # Simulate build process
      sleep 1
      
      mkdir -p build
      echo "Built at $(date)" > build/build-info.txt
      echo "Version: {{ .version }}" >> build/build-info.txt
      echo "Environment: {{ .environment }}" >> build/build-info.txt
      
      # Create build artifacts
      cp -r src build/
      cp -r config build/
      
      log_success "Application build completed"

  # Test recipe
  test:
    help: "Run application tests"
    deps: ["build"]
    run: |
      log_step "Running tests for {{ .project_name }}..."
      
      # Simulate test execution
      log_info "Running unit tests..."
      sleep 1
      
      log_info "Running integration tests..."
      sleep 1
      
      # Create test results
      mkdir -p test-results
      cat > test-results/results.xml << 'EOF'
      <?xml version="1.0" encoding="UTF-8"?>
      <testsuites>
        <testsuite name="unit-tests" tests="5" failures="0" time="1.2">
          <testcase name="test_version" time="0.1"/>
          <testcase name="test_config" time="0.2"/>
          <testcase name="test_setup" time="0.3"/>
          <testcase name="test_build" time="0.4"/>
          <testcase name="test_deploy" time="0.2"/>
        </testsuite>
      </testsuites>
      EOF
      
      log_success "All tests passed!"

  # Package recipe
  package:
    help: "Create distribution package"
    deps: ["test"]
    run: |
      log_step "Creating distribution package..."
      
      mkdir -p dist
      
      # Create distribution archive
      tar -czf "dist/{{ .project_name }}-{{ .version }}.tar.gz" \
        -C build . \
        --transform 's,^,{{ .project_name }}-{{ .version }}/,'
      
      # Create package metadata
      cat > dist/package.json << 'EOF'
      {
        "name": "{{ .project_name }}",
        "version": "{{ .version }}",
        "environment": "{{ .environment }}",
        "build_date": "{{ .BUILD_DATE }}",
        "package_date": "$(date -Iseconds)",
        "files": [
          "{{ .project_name }}-{{ .version }}.tar.gz"
        ]
      }
      EOF
      
      log_success "Distribution package created"

  # Deploy recipe with environment selection
  deploy:
    help: "Deploy to environment"
    deps: ["package"]
    positionals:
      - name: target_env
        default: "{{ .environment }}"
        one_of: ["development", "staging", "production"]
    run: |
      log_step "Deploying {{ .project_name }} to {{ .target_env }}..."
      
      {{ if eq .target_env "production" }}
      log_warning "PRODUCTION DEPLOYMENT!"
      echo -n "Are you sure? (y/N): "
      read -r confirm
      if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
        log_error "Deployment cancelled"
        exit 1
      fi
      {{ end }}
      
      # Simulate deployment
      log_info "Uploading package to {{ .target_env }}..."
      sleep 2
      
      log_info "Updating {{ .target_env }} configuration..."
      sleep 1
      
      log_info "Restarting services in {{ .target_env }}..."
      sleep 1
      
      log_success "Deployment to {{ .target_env }} completed!"

  # Complete CI pipeline using both local and namespaced recipes
  full-ci:
    help: "Run complete CI pipeline (local + Docker)"
    deps: ["test", "docker:build"]  # Mix of local and namespaced dependencies
    run: |
      log_step "Running complete CI pipeline..."
      
      log_info "✅ Application tests passed"
      log_info "✅ Docker image built"
      
      # Now run additional CI steps
      log_info "Running security scans..."
      sleep 1
      
      log_info "Running quality checks..."
      sleep 1
      
      log_success "Complete CI pipeline finished!"
      echo ""
      echo "Next steps:"
      echo "  drun package        # Create distribution"
      echo "  drun docker:push    # Push Docker image"
      echo "  drun deploy staging # Deploy to staging"

  # Cleanup recipe
  cleanup:
    help: "Clean up all build artifacts"
    run: |
      log_step "Cleaning up build artifacts..."
      
      # Remove build directories
      for dir in build dist test-results .pipeline; do
        if [ -d "$dir" ]; then
          rm -rf "$dir"
          log_info "Removed $dir/"
        fi
      done
      
      # Clean Docker resources too
      log_info "Also cleaning Docker resources..."
      
      log_success "Cleanup completed"

  # Show pipeline status
  status:
    help: "Show current pipeline status"
    run: |
      log_info "Pipeline Status for {{ .project_name }}"
      echo ""
      
      if [ -f .pipeline/state.env ]; then
        source .pipeline/state.env
        echo "Pipeline ID: $pipeline_id"
        echo "Project: $project"
        echo "Version: $version"
        echo "Environment: $environment"
        echo "Start Time: $(date -d @$start_time 2>/dev/null || date -r $start_time 2>/dev/null || echo $start_time)"
        
        if [ -n "$start_time" ]; then
          CURRENT_DURATION=$(($(date +%s) - start_time))
          echo "Running Time: ${CURRENT_DURATION}s"
        fi
      else
        echo "No active pipeline found"
      fi
      
      echo ""
      echo "Artifacts:"
      find . -name "*.tar.gz" -o -name "*.xml" -o -name "*.json" 2>/dev/null | head -10 | while read -r file; do
        echo "  $file"
      done

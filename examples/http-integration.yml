version: 0.1

# HTTP endpoint definitions
http:
  # GitHub API endpoint
  github:
    url: "https://api.github.com"
    headers:
      Accept: "application/vnd.github.v3+json"
      User-Agent: "drun/1.4"
    timeout: 30s
    retry:
      max_attempts: 3
      backoff: "exponential"
      base_delay: 1s
      max_delay: 10s
    cache:
      ttl: 5m
    description: "GitHub API v3"

  # Slack webhook for notifications
  slack:
    url: "{{ env \"SLACK_WEBHOOK_URL\" }}"
    method: "POST"
    headers:
      Content-Type: "application/json"
    timeout: 10s
    description: "Slack webhook for notifications"

  # API with authentication
  api:
    url: "https://api.example.com"
    headers:
      Content-Type: "application/json"
    auth:
      type: "bearer"
      token: "{{ secret \"api_token\" }}"
    timeout: 30s
    retry:
      max_attempts: 5
      backoff: "exponential"
      base_delay: 2s
    cache:
      ttl: 1m
    description: "Example API with bearer auth"

  # Service health check
  health:
    url: "https://service.example.com/health"
    method: "GET"
    timeout: 5s
    retry:
      max_attempts: 3
      backoff: "fixed"
      base_delay: 1s
    description: "Service health check endpoint"

# Secrets for API authentication
secrets:
  api_token:
    source: "env://API_TOKEN"
    required: true
    description: "API authentication token"

# Environment variables
env:
  SERVICE_NAME: "my-service"
  VERSION: "1.0.0"

recipes:
  # Get GitHub user information
  github-user:
    help: "Get GitHub user information"
    positionals:
      - name: username
        required: true
    run: |
      {{ step "Fetching GitHub user info for {{ .username }}" }}
      
      # Make HTTP call to GitHub API
      {{ $user := httpCallJSON "github" (dict "url" (printf "/users/%s" .username)) }}
      
      {{ info (printf "User: %s (%s)" $user.name $user.login) }}
      {{ info (printf "Public repos: %v" $user.public_repos) }}
      {{ info (printf "Followers: %v" $user.followers) }}
      {{ info (printf "Following: %v" $user.following) }}
      
      {{ success "User information retrieved successfully" }}

  # Send Slack notification
  notify-slack:
    help: "Send notification to Slack"
    positionals:
      - name: message
        required: true
    run: |
      {{ step "Sending Slack notification" }}
      
      # Prepare Slack payload
      {{ $payload := dict "text" .message "username" "drun" "icon_emoji" ":robot_face:" }}
      
      # Send to Slack
      {{ httpPost (env "SLACK_WEBHOOK_URL") $payload }}
      
      {{ success "Notification sent to Slack" }}

  # API data retrieval with caching
  fetch-data:
    help: "Fetch data from API with caching"
    positionals:
      - name: endpoint
        required: true
    run: |
      {{ step "Fetching data from API" }}
      
      # Make cached API call
      {{ $data := httpCallJSON "api" (dict "url" (printf "/%s" .endpoint)) }}
      
      {{ info (printf "Retrieved %d items" (len $data.items)) }}
      
      # Process the data
      {{ range $item := $data.items }}
      echo "Processing: {{ $item.name }}"
      {{ end }}
      
      {{ success "Data processing completed" }}

  # Health check with retry
  health-check:
    help: "Check service health"
    run: |
      {{ step "Checking service health" }}
      
      # Health check with automatic retries
      {{ $health := httpCallJSON "health" }}
      
      {{ if eq $health.status "healthy" }}
      {{ success "Service is healthy" }}
      {{ else }}
      {{ error (printf "Service is unhealthy: %s" $health.status) }}
      exit 1
      {{ end }}

  # Complex workflow with multiple HTTP calls
  deploy-workflow:
    help: "Complex deployment workflow with HTTP calls"
    run: |
      {{ step "Starting deployment workflow" }}
      
      # 1. Check service health before deployment
      {{ info "Checking current service health..." }}
      {{ $preHealth := httpCallJSON "health" }}
      {{ info (printf "Pre-deployment health: %s" $preHealth.status) }}
      
      # 2. Get current version from API
      {{ info "Getting current version..." }}
      {{ $version := httpCallJSON "api" (dict "url" "/version") }}
      {{ info (printf "Current version: %s" $version.version) }}
      
      # 3. Notify deployment start
      {{ $startMsg := printf "üöÄ Starting deployment of %s v%s" (env "SERVICE_NAME") (env "VERSION") }}
      {{ httpPost (env "SLACK_WEBHOOK_URL") (dict "text" $startMsg) }}
      
      # 4. Simulate deployment steps
      {{ info "Performing deployment..." }}
      sleep 2
      
      # 5. Post-deployment health check
      {{ info "Post-deployment health check..." }}
      {{ $postHealth := httpCallJSON "health" }}
      
      {{ if eq $postHealth.status "healthy" }}
      # 6. Success notification
      {{ $successMsg := printf "‚úÖ Successfully deployed %s v%s" (env "SERVICE_NAME") (env "VERSION") }}
      {{ httpPost (env "SLACK_WEBHOOK_URL") (dict "text" $successMsg) }}
      {{ success "Deployment completed successfully" }}
      {{ else }}
      # 6. Failure notification
      {{ $failMsg := printf "‚ùå Deployment failed for %s v%s - Health check failed" (env "SERVICE_NAME") (env "VERSION") }}
      {{ httpPost (env "SLACK_WEBHOOK_URL") (dict "text" $failMsg) }}
      {{ error "Deployment failed - service unhealthy" }}
      exit 1
      {{ end }}

  # Dynamic API calls based on conditions
  conditional-api:
    help: "Make different API calls based on conditions"
    flags:
      environment:
        type: "string"
        default: "dev"
        help: "Target environment"
    run: |
      {{ step "Making conditional API calls" }}
      
      {{ if eq .flags.environment "prod" }}
      {{ info "Production environment detected" }}
      
      # Production-specific API calls
      {{ $prodData := httpCallJSON "api" (dict "url" "/prod/status") }}
      {{ info (printf "Production status: %s" $prodData.status) }}
      
      {{ else }}
      {{ info "Development environment detected" }}
      
      # Development-specific API calls
      {{ $devData := httpCallJSON "api" (dict "url" "/dev/status") }}
      {{ info (printf "Development status: %s" $devData.status) }}
      
      {{ end }}
      
      {{ success "Conditional API calls completed" }}

  # Error handling with HTTP calls
  error-handling:
    help: "Demonstrate error handling with HTTP calls"
    run: |
      {{ step "Testing error handling" }}
      
      # Try to make a call that might fail
      {{ $result := "" }}
      {{ $error := "" }}
      
      # This would normally use a try-catch mechanism
      # For now, we'll demonstrate with a working call
      {{ $result = httpGet "https://httpbin.org/json" }}
      
      {{ if $result }}
      {{ success "HTTP call succeeded" }}
      echo "Response: {{ $result }}"
      {{ else }}
      {{ error "HTTP call failed" }}
      {{ end }}

  # Batch HTTP operations
  batch-operations:
    help: "Perform batch HTTP operations"
    run: |
      {{ step "Performing batch HTTP operations" }}
      
      # Define a list of endpoints to check
      {{ $endpoints := list "/users" "/posts" "/comments" }}
      
      {{ range $endpoint := $endpoints }}
      {{ info (printf "Checking endpoint: %s" $endpoint) }}
      
      # Make API call for each endpoint
      {{ $data := httpCallJSON "api" (dict "url" $endpoint) }}
      {{ info (printf "Endpoint %s returned %d items" $endpoint (len $data)) }}
      {{ end }}
      
      {{ success "Batch operations completed" }}

  # HTTP call with custom headers and parameters
  custom-request:
    help: "Make HTTP call with custom headers and parameters"
    positionals:
      - name: query
        required: true
    run: |
      {{ step "Making custom HTTP request" }}
      
      # Custom headers and query parameters
      {{ $options := dict 
           "headers" (dict "X-Custom-Header" "custom-value" "X-Request-ID" (now "20060102150405"))
           "query" (dict "q" .query "limit" "10" "sort" "created_at")
           "timeout" "15s"
      }}
      
      # Make the call with custom options
      {{ $result := httpCallJSON "api" $options }}
      
      {{ info (printf "Found %d results for query: %s" (len $result.items) .query) }}
      
      {{ success "Custom request completed" }}

  # WebHook receiver simulation
  webhook-test:
    help: "Test webhook functionality"
    run: |
      {{ step "Testing webhook functionality" }}
      
      # Simulate webhook payload
      {{ $webhook := dict 
           "event" "deployment"
           "service" (env "SERVICE_NAME")
           "version" (env "VERSION")
           "timestamp" (now "2006-01-02T15:04:05Z07:00")
           "status" "success"
      }}
      
      # Send webhook
      {{ httpPost "https://webhook.site/your-unique-url" $webhook }}
      
      {{ success "Webhook test completed" }}

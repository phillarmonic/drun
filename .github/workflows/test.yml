name: Test Suite

on:
  push:
    branches: [ master, develop ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - 'examples/**/*.md'
      - 'LICENSE'
      - 'ROADMAP.md'
      - 'TEMPLATE_FUNCTIONS.md'
      - 'spec.md'
  pull_request:
    branches: [ master, develop ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - 'examples/**/*.md'
      - 'LICENSE'
      - 'ROADMAP.md'
      - 'TEMPLATE_FUNCTIONS.md'
      - 'spec.md'

# Cancel previous runs when new commits are pushed
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # Lint job runs first and is required for all other jobs
  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v5

    - name: Set up Go
      uses: actions/setup-go@v6
      with:
        go-version: 1.25
        cache: true
        cache-dependency-path: go.sum

    - name: Download dependencies
      run: go mod download

    - name: Run golangci-lint
      uses: golangci/golangci-lint-action@v8
      with:
        version: latest
        args: --timeout=5m

  # Test job depends on successful lint
  test:
    name: Test
    runs-on: ${{ matrix.os }}
    needs: lint  # Only run after lint succeeds
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        go-version: [1.25]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v5

    - name: Set up Go
      uses: actions/setup-go@v6
      with:
        go-version: ${{ matrix.go-version }}
        cache: true
        cache-dependency-path: go.sum

    - name: Download dependencies
      run: go mod download

    - name: Install coreutils on macOS (for timeout command)
      if: runner.os == 'macOS'
      run: |
        echo "Installing coreutils for gtimeout command..."
        brew install coreutils

    - name: Run tests (Unix)
      if: runner.os != 'Windows'
      run: ./scripts/test-ci.sh

    - name: Run tests (Windows)
      if: runner.os == 'Windows'
      shell: bash
      run: |
        echo "Running CI Test Suite..."
        echo "Cleaning up any .out files..."
        find . -name "*.out" -type f -delete 2>/dev/null || true
        echo "Testing race..."
        mkdir -p coverage
        
        # Run race tests with timeout (10 minutes max)
        echo "â±ï¸  Running race condition tests with 10-minute timeout..."
        if timeout 600 go test -race -cover -coverprofile=coverage/coverage.out ./internal/...; then
          echo "âœ… Race condition tests completed successfully"
        else
          exit_code=$?
          if [ $exit_code -eq 124 ]; then
            echo "âŒ Race condition tests timed out after 10 minutes!"
            echo "This may indicate a deadlock or infinite loop in the code."
            exit 1
          else
            echo "âŒ Race condition tests failed with exit code $exit_code"
            exit $exit_code
          fi
        fi
        
        echo "Building the binary..."
        go build -o bin/xdrun.exe ./cmd/drun
        if [ $? -ne 0 ]; then
          echo "âŒ Build failed!"
          exit 1
        fi
        echo "Testing the binary..."
        ./bin/xdrun.exe --version
        if [ $? -ne 0 ]; then
          echo "âŒ Binary test failed!"
          exit 1
        fi
        echo "CI tests passed!"

    - name: Upload coverage to Codecov
      if: matrix.os == 'ubuntu-latest' && matrix.go-version == '1.25'
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage/coverage.cov
        flags: unittests
        name: codecov-umbrella

  # Build job also depends on successful lint
  build:
    name: Build
    runs-on: ${{ matrix.os }}
    needs: lint  # Only run after lint succeeds
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v5

    - name: Set up Go
      uses: actions/setup-go@v6
      with:
        go-version: 1.25
        cache: true
        cache-dependency-path: go.sum

    - name: Download dependencies
      run: go mod download

    - name: Build binary (Unix)
      if: runner.os != 'Windows'
      run: |
        go build -ldflags "-X main.version=ci-build -X main.commit=${{ github.sha }} -X main.date=$(date -u +%Y-%m-%dT%H:%M:%SZ)" -o bin/xdrun ./cmd/drun
        ./bin/xdrun --version

    - name: Build binary (Windows)
      if: runner.os == 'Windows'
      shell: bash
      run: |
        go build -ldflags "-X main.version=ci-build -X main.commit=${{ github.sha }} -X main.date=$(date -u +%Y-%m-%dT%H:%M:%SZ)" -o bin/xdrun.exe ./cmd/drun
        ./bin/xdrun.exe --version

    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: xdrun-${{ runner.os }}
        path: bin/xdrun*

  # Example file testing job - tests parsing and execution of example files
  test-examples:
    name: Test Examples on ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    needs: lint  # Only run after lint succeeds
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v5

    - name: Configure Git line endings (Windows)
      if: runner.os == 'Windows'
      run: |
        git config --global core.autocrlf false
        git config --global core.eol lf

    - name: Set up Go
      uses: actions/setup-go@v6
      with:
        go-version: 1.25
        cache: true
        cache-dependency-path: go.sum

    - name: Download dependencies
      run: go mod download

    - name: Install coreutils on macOS (for timeout command)
      if: runner.os == 'macOS'
      run: |
        echo "Installing coreutils for gtimeout command..."
        brew install coreutils

    - name: Build drun binary (Unix)
      if: runner.os != 'Windows'
      run: |
        go build -o bin/xdrun ./cmd/drun
        ./bin/xdrun --version

    - name: Build drun binary (Windows)
      if: runner.os == 'Windows'
      run: |
        go build -o bin/xdrun.exe ./cmd/drun
        ./bin/xdrun.exe --version

    - name: Test parsing of all example files
      shell: bash
      run: |
        echo "ðŸ§ª Testing parsing of all example files on ${{ matrix.os }}..."
        
        # Set binary name and timeout command based on OS
        if [[ "${{ runner.os }}" == "Windows" ]]; then
          DRUN_BIN="./bin/xdrun.exe"
          TIMEOUT_CMD="timeout 60"
        elif [[ "${{ runner.os }}" == "macOS" ]]; then
          DRUN_BIN="./bin/xdrun"
          TIMEOUT_CMD="gtimeout 60"  # coreutils installed in previous step
        else
          DRUN_BIN="./bin/xdrun"
          TIMEOUT_CMD="timeout 60"
        fi
        
        # Test that all example files can be parsed without errors
        failed_files=()
        
        for file in examples/*.drun; do
          if [[ -f "$file" ]]; then
            echo -n "ðŸ“„ Testing parsing: $file ... "
            
            # Use timeout to prevent infinite loops (60 seconds)
            if $TIMEOUT_CMD $DRUN_BIN --list --file "$file" >/dev/null 2>/tmp/parse_error.log; then
              echo "âœ… SUCCESS"
            else
              exit_code=$?
              echo "âŒ FAILED"
              
              # Show the actual error output
              echo "    Error details for $file:"
              if [[ $exit_code -eq 124 ]]; then
                echo "      â° TIMEOUT: Parsing took longer than 60 seconds (possible infinite loop)"
              else
                echo "      Exit code: $exit_code"
                if [[ -f /tmp/parse_error.log ]]; then
                  sed 's/^/      /' /tmp/parse_error.log
                else
                  echo "      No error log available"
                fi
              fi
              echo ""
              echo "âŒ STOPPING: First parsing failure detected. Fix this issue before continuing."
              echo "   Failed file: $file"
              exit 1
            fi
          fi
        done
        
        echo "âœ… All $(ls examples/*.drun | wc -l) example files parsed successfully!"

    - name: Test safe example executions
      shell: bash
      run: |
        echo "ðŸš€ Testing execution of safe example files..."
        
        # Set binary name and timeout command based on OS
        if [[ "${{ runner.os }}" == "Windows" ]]; then
          DRUN_BIN="./bin/xdrun.exe"
          TIMEOUT_CMD="timeout 60"
        elif [[ "${{ runner.os }}" == "macOS" ]]; then
          DRUN_BIN="./bin/xdrun"
          TIMEOUT_CMD="gtimeout 60"  # coreutils installed in previous step
        else
          DRUN_BIN="./bin/xdrun"
          TIMEOUT_CMD="timeout 60"
        fi
        
        # Helper function to run with timeout and error handling
        run_with_timeout() {
          local file="$1"
          local task="$2"
          shift 2
          local args="$@"
          
          echo -n "ðŸ“„ Testing: $file -> $task ... "
          
          # Execute with timeout
          if $TIMEOUT_CMD $DRUN_BIN "$task" --file "$file" $args >/dev/null 2>/tmp/exec_error.log; then
            echo "âœ… SUCCESS"
          else
            exit_code=$?
            echo "âŒ FAILED"
            echo "    Error details for $file -> $task:"
            if [[ $exit_code -eq 124 ]]; then
              echo "      â° TIMEOUT: Execution took longer than 60 seconds"
            else
              echo "      Exit code: $exit_code"
              if [[ -f /tmp/exec_error.log ]]; then
                sed 's/^/      /' /tmp/exec_error.log
              fi
            fi
            echo ""
            echo "âŒ STOPPING: First execution failure detected. Fix this issue before continuing."
            echo "   Failed: $file -> $task"
            exit 1
          fi
        }
        
        # Test basic hello world
        run_with_timeout "examples/01-hello-world.drun" "hello"
        run_with_timeout "examples/01-hello-world.drun" "hello world"
        
        # Test interpolation (safe tasks only)
        run_with_timeout "examples/03-interpolation.drun" "greet" name="CI Test" title="GitHub Actions"
        
        # Test project declarations
        run_with_timeout "examples/21-project-declarations.drun" "build"
        run_with_timeout "examples/21-project-declarations.drun" "status"
        
        # Test explicit indentation
        run_with_timeout "examples/15-explicit-indent.drun" "explicit indent"
        
        # Test builtin functions (safe ones)
        run_with_timeout "examples/08-builtin-functions.drun" "system info"
        
        echo "âœ… All safe example executions completed successfully!"

    - name: Test Windows-specific parsing edge cases
      if: matrix.os == 'windows-latest'
      shell: bash
      run: |
        echo "ðŸªŸ Testing Windows-specific parsing scenarios..."
        
        DRUN_BIN="./bin/xdrun.exe"
        
        # Helper function for Windows tests with timeout
        test_windows_file() {
          local file="$1"
          local task="$2"
          
          echo -n "ðŸ“„ Windows test: $file"
          if [[ -n "$task" ]]; then
            echo -n " -> $task"
          fi
          echo -n " ... "
          
          if [[ -z "$task" ]]; then
            # Just list tasks
            if timeout 60 $DRUN_BIN --list --file "$file" >/dev/null 2>/tmp/win_error.log; then
              echo "âœ… SUCCESS"
            else
              exit_code=$?
              echo "âŒ FAILED"
              echo "    Error details:"
              if [[ $exit_code -eq 124 ]]; then
                echo "      â° TIMEOUT: Operation took longer than 60 seconds"
              else
                echo "      Exit code: $exit_code"
                if [[ -f /tmp/win_error.log ]]; then
                  sed 's/^/      /' /tmp/win_error.log
                fi
              fi
              echo ""
              echo "âŒ STOPPING: First Windows test failure detected. Fix this issue before continuing."
              echo "   Failed: $file"
              exit 1
            fi
          else
            # Execute specific task
            if timeout 60 $DRUN_BIN "$task" --file "$file" >/dev/null 2>/tmp/win_error.log; then
              echo "âœ… SUCCESS"
            else
              exit_code=$?
              echo "âŒ FAILED"
              echo "    Error details:"
              if [[ $exit_code -eq 124 ]]; then
                echo "      â° TIMEOUT: Execution took longer than 60 seconds"
              else
                echo "      Exit code: $exit_code"
                if [[ -f /tmp/win_error.log ]]; then
                  sed 's/^/      /' /tmp/win_error.log
                fi
              fi
              echo ""
              echo "âŒ STOPPING: First Windows test failure detected. Fix this issue before continuing."
              echo "   Failed: $file -> $task"
              exit 1
            fi
          fi
        }
        
        echo "Testing examples with blank lines and complex formatting..."
        
        # Test hello world (has blank lines)
        test_windows_file "examples/01-hello-world.drun"
        test_windows_file "examples/01-hello-world.drun" "hello"
        
        # Test parameters (complex structure with blank lines)
        test_windows_file "examples/02-parameters.drun"
        
        # Test project declarations (has project block with blank lines)
        test_windows_file "examples/21-project-declarations.drun"
        test_windows_file "examples/21-project-declarations.drun" "build"
        
        # Test variable operations (complex with multiple blank line sections)
        test_windows_file "examples/28-variable-operations.drun"
        test_windows_file "examples/28-variable-operations.drun" "basic_variable_operations"
        
        # Test builtin functions (has various formatting)
        test_windows_file "examples/08-builtin-functions.drun"
        test_windows_file "examples/08-builtin-functions.drun" "system info"
        
        # Test lifecycle hooks (complex indentation and blank lines)
        test_windows_file "examples/39-drun-lifecycle-hooks.drun"
        
        echo "âœ… All Windows-specific parsing tests passed!"
